---
title: "Untitled"
format: html
---


```{python}
import polars as pl
from patsy import dmatrix
import pymc as pm
import numpy as np
import arviz as az
from plotnine import *
palette = ["#001e42", "#535c78", "#9fa3b3", "#f1f1f1", "#ffbea4", "#ff895a", "#ff4b00"]
```


```{python}
df_field_goals = pl.read_csv("data/field_goal_attempts.csv")
df_kickers = pl.read_csv("data/kickers.csv")

df = (
    df_field_goals.join(df_kickers, on="player_id")
    .rename({"attempt_yards": "distance"})
    .with_columns(
        success=pl.when(pl.col("field_goal_result") == "Made")
        .then(pl.lit(1))
        .otherwise(pl.lit(0)),
        player_id=pl.col("player_id").cast(pl.Utf8).cast(pl.Categorical),
        player_name=pl.col("player_name").cast(pl.Categorical),
        season_type=pl.col("season_type").cast(pl.Categorical),
    )
    .with_columns(
        player_idx=pl.col("player_id").to_physical().cast(pl.Int64)
        + 1
    )
)

```


```{python}
df_plot = df.group_by("distance").agg(pl.col("success").sum() / pl.count("success"))
(
    ggplot(df_plot, aes("distance", "success"))
    + geom_smooth(color=palette[0], se=False)  # 'lowess CI isn't avialble yet'
    + geom_point(alpha=0.2, color=palette[0])
    + labs(
        title="Success Rate by Distance - Observed Data",
        x="Attempt Distance (yards)",
        y="Success Rate",
    )
    + theme_minimal()
)

```


```{python}
def prepare_data(df):
    df = df.with_columns(
        distance_std=(pl.col("distance") - pl.col("distance").mean())
        / pl.col("distance").std()
    )

    spline_basis = dmatrix(
        "bs(distance_std, df=4, include_intercept = False) - 1",  # removed include_intercept=True) - 1",
        data=df.to_pandas(),
        return_type="dataframe",
    )

    return {
        "distance": df["distance_std"].to_numpy(),
        "spline_array": np.asarray(spline_basis, order="F"),
        "player": df["player_id"].to_physical().cast(pl.Int64).to_numpy(),
        "player_cat": df["player_id"].cat.get_categories(),
        "spline_shape": np.arange(spline_basis.shape[1]),
        "spline_basis": spline_basis,
    }


data = prepare_data(df)

COORDS = {
    "splines": data["spline_shape"],
    "player_id": data["player_cat"],
}
```


```{python}

with pm.Model(coords=COORDS) as model:
    spline_data = pm.Data("spline_data", data["spline_array"])
    player_idx = pm.Data("player_idx", data["player"])

    # ------------- PARAMETERS ---------------------------
    # intercept
    alpha = pm.Normal("alpha", mu=1, sigma=1)

    # splines
    # sigma_w = pm.HalfStudentT("sigma_w", nu=3, sigma=1)
    w = pm.StudentT("w", nu=3, mu=0, sigma=1, dims="splines")
    spline_contrib = pm.math.dot(spline_data, w.T)

    # player effects
    player_offset = pm.Normal("player_offset", mu=0, sigma=1, dims="player_id")
    sigma = pm.HalfNormal("sigma", sigma=0.5)
    player_effect = pm.Deterministic("1|player_id", player_offset * sigma)


    mu = alpha + player_effect[player_idx] + spline_contrib
    p = pm.Deterministic("p", pm.math.invlogit(mu))

    pm.Bernoulli("y_rep", p=p, observed=df["success"].to_numpy())

    mu_baseline = alpha + spline_contrib
    p_baseline = pm.Deterministic("p_baseline", pm.math.invlogit(mu_baseline))


with model:
    idata = pm.sample_prior_predictive()
    idata.extend(pm.sample(cores=1, chains=4, target_accept=0.9, random_seed=527))

# az.to_netcdf(idata, 'model_results.nc')
#idata = az.from_netcdf('model_results.nc')
```

Prior ------

```{python}
df_prior = pl.from_pandas(
    idata.prior_predictive["y_rep"].to_dataframe().reset_index()
).rename({"y_rep": "success"})

(
    ggplot(aes("success", "len"))
    + geom_col(
        aes(group="draw", color="t"),
        position="identity",
        fill=None,
        alpha=0.01,
        data=(
            df_prior.group_by(["draw", "success"])
            .len()
            .with_columns(t=pl.lit("prior predictive"))
        ),
    )
    + geom_col(
        aes(color="t"),
        fill=None,
        size=1.5,
        data=(
            df_prior.group_by(["draw", "success"])
            .len()
            .group_by("success")
            .agg(pl.col("len").mean())
            .with_columns(t=pl.lit("prior predictive mean"))
        ),
    )
    + theme_minimal()
    + labs(title="Prior Predictive Checks", x="Success", y="Count", color="")
    + scale_x_continuous(breaks=[0, 1])
    + theme(
        panel_grid_minor=element_blank(),
        panel_grid_major_x=element_blank(),
        legend_position='top',
        legend_background=element_blank(),
    )
    + scale_color_manual(values=(palette[2], palette[-1]))
)

```

Posterior ---------

```{python}
az.plot_trace(idata, var_names=["1|player_id"], kind="rank_bars")
az.summary(idata, var_names=["1|player_id"])
```

```{python}
df_2018 = (
    df.filter(pl.col("season") == 2018)
    .select(["player_id", "player_name", "player_idx"])
    .unique()
    .join(
        pl.DataFrame({"distance": [x for x in range(25, 60)]}).with_columns(
            distance_std=(pl.col("distance") - pl.col("distance").mean())
            / pl.col("distance").std()
        ),
        how="cross",
    )
)

df_2018

```


```{python}
#with model:

   # df_pred = pm.sample_posterior_predictive(idata, var_names=["p", 'y_rep'], random_seed=123)

#az.plot_ppc(df_pred, group='posterior', num_pp_samples=10)
```


```{python}
design_info = data["spline_basis"].design_info
spline_array = data["spline_basis"].values

spline_2018 = dmatrix(design_info, df_2018.to_pandas(), return_type="dataframe")
spline_array_2018 = spline_2018.values
```

```{python}
with model:
    pm.set_data(
        {
            "player_idx": np.zeros_like(
                df_2018["player_id"].to_numpy(), dtype=np.int64
            ),  # or exclude entirely
            "spline_data": spline_array_2018,
        }
    )
    pred_baseline = pm.sample_posterior_predictive(idata, var_names=["p_baseline"])

df_pred_baseline = pl.from_pandas(
    pred_baseline.posterior_predictive["p_baseline"].to_dataframe().reset_index()
).rename({'p_baseline_dim_0': 'p_dim_0'})

with model:
    pm.set_data(
        {
            "player_idx": df_2018["player_id"]
            .to_physical()
            .cast(pl.Int64)
            .to_numpy(),
            "spline_data": spline_array_2018,
        }
    )
    pred_2018 = pm.sample_posterior_predictive(idata, var_names=["p"])


df_output = (
    df_2018.with_row_index("p_dim_0")
    .join(
        pl.from_pandas(pred_2018.posterior_predictive["p"].to_dataframe().reset_index()),
        on="p_dim_0",
    )
    .join(df_pred_baseline, on=["chain", "draw", "p_dim_0"])
    .with_columns(diff=pl.col("p") - pl.col("p_baseline"))
    .group_by(["player_name", "player_id", "chain", "draw"])
    .agg(fgoe=pl.col("diff").sum())
)
```




```{python}
df_output.group_by(["player_name"]).agg(pl.col("fgoe").mean()).sort("fgoe")

ggpointinterval(df_output, "test", "fgoe")


```




### Recreate

#### Spline


```{python}
import polars.selectors as cs
from plotnine import *
_w = idata.posterior['w'].mean(['chain', 'draw']).values


_df_spline = pl.DataFrame(data['spline_basis'].values * _w.T).with_columns(
    distance = df['distance']
).unpivot(cs.starts_with('col'), index='distance')


ggplot(_df_spline, aes('distance', 'value')) + geom_line(aes(color='variable'))

```


```{python}


(

    ggplot(
        _df_spline.group_by("distance").agg(pl.col("value").mean()),
        aes("distance", "value"),
    )
    + geom_line()
)  # geom_line(aes(color="variable"))
```

Spline prediction output

```{python}
_df_base = (
    df_pred_baseline.join(df_2018.with_row_index("p_dim_0"), on="p_dim_0")
    .group_by(["distance"])
    .agg(
        x=pl.col("p_baseline").min(),
        y= pl.col('p_baseline').max(),
        z = pl.col('p_baseline').median()
        )
)

ggplot(_df_base, aes("distance", "z")) + geom_line() + geom_ribbon(aes(ymin='x', ymax='y'), alpha = 0.2)

```

which player


```{python}
plot_df = (
    df_2018.with_row_index("p_dim_0")
    .join(
        pl.from_pandas(pred_2018.posterior_predictive["p"].to_dataframe().reset_index()),
        on="p_dim_0",
    )
    .join(df_pred_baseline, on=["chain", "draw", "p_dim_0"])
    .with_columns(fgoe=pl.col("p") - pl.col("p_baseline"))
    .filter(pl.col('player_name').is_in(['JUSTIN TUCKER', 'ZANE GONZALEZ']))
    .with_columns(pl.col('player_name').cast(pl.Utf8))
)
(
    ggplot(aes("distance", "p", color="player_name"))
    + geom_ribbon(
        aes(y="fgoe", ymin="ymin", ymax="ymax", fill="player_name"),
        data=pointrange_data(plot_df, field="p", group=["player_name", "distance"]),
        alpha=0.2,
        outline_type=element_blank(),
        show_legend={"color": False},
    )
    + geom_ribbon(
        aes(y="fgoe", ymin="hdi_lower", ymax="hdi_upper", fill="player_name"),
        # fill="#00000053",
        data=pointrange_data(plot_df, field="p", group=["player_name", "distance"]),
        alpha=0.4,
        outline_type=element_blank(),
        show_legend={"color": False},
    )
    + geom_line(
        data=plot_df.group_by(["player_name", "distance"]).agg(pl.col("p").median()),
        size=1.5,
        show_legend=False,
    )
    + theme_minimal()
    + theme(legend_position="top", panel_grid_minor=element_blank())
    + labs(
        title="Modeled Probability by Distance",
        y="P(Make)",
        x="Distance",
        fill="Player:",
    )
    + scale_x_continuous(limits=(25, 60))
    + scale_color_manual(values=(palette[-1], palette[0]))
    + scale_fill_manual(values=(palette[-1], palette[0]))
)
```
