<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>summary</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="summary_files/libs/clipboard/clipboard.min.js"></script>
<script src="summary_files/libs/quarto-html/quarto.js"></script>
<script src="summary_files/libs/quarto-html/popper.min.js"></script>
<script src="summary_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="summary_files/libs/quarto-html/anchor.min.js"></script>
<link href="summary_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="summary_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="summary_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="summary_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="summary_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="assumptions" class="level2">
<h2 class="anchored" data-anchor-id="assumptions">Assumptions</h2>
<p>I went about this how I would if I was asked to start this in real life, start simple - prioritize explainability over complexity. I also used python because I recalled that the job posting specified python and PYMC.</p>
</section>
<section id="how-could-your-work-be-improved" class="level2">
<h2 class="anchored" data-anchor-id="how-could-your-work-be-improved">How could your work be improved?</h2>
<p>Using <code>ggplot</code>… Kidding, but data visualization is critical to communicating effectively. With more time, I’d refine the charts for various audiences. For instance, clearly annotating visualizations and highlighting key points – like a specific player’s data in the forest plot – would significantly improve their clarity. My aim would be to create a comprehensive deliverable: an Executive Summary for leadership, detailed technical information for the Football Research &amp; Technology team, and a general presentation for the broader organization. The best way to make an impact is to bring everyone along with the project, and tailored visualizations and tables are key to that.</p>
<p>That brings up another point in how this could be improved, which is feedback from stakeholders. It’s critical to understand who is using it? How is this getting used? What information do we have currently and what areas are indentified as missing. All of which would provide guidence on what design direction some of this should take. The kick distribution within the model is linear values from 25-60, this is an are where feedback from leadership on what type of kicks do we want to model kickers. Do we want to look at a standard season distribution, or would we want to look at aggressive kicking seasons assuming we utilize the kicker in more difficult situations.</p>
<p>Within the scope of the data, I didn’t incorporate anything related to age or look into weighing newer seasons for a player differently. For age, this dataset in particular has Adam Vinitari who exceled into his 40’s. I did some basic analysis to look into it, and without accounting for survivorship bias (where only high-performing kickers remain in the league into older age), a naive model might attribute positive effects to increasing age. Additionally, a time series component could be included to downweight past seasons. Neither are out of the scope of what can be done with this ask, but I’m confident with the presented model as a first pass before adding in more complexity. I also looked into random effects on distance per player, but the spline performed slighly better and dealt with less parameters, thus less complexity. My theory is that at certain distances, players are constrained more by physics than skill, and the spline’s flexibility in capturing non-linear relationships at these specific points offered a better fit than a simple random intercept/slope for each player.</p>
</section>
<section id="given-more-time-what-would-your-next-steps-be" class="level2">
<h2 class="anchored" data-anchor-id="given-more-time-what-would-your-next-steps-be">Given more time, what would your next steps be?</h2>
<p>There are components I mentioned above, but I think theres a couple directions. Adding in tracking data could be one, but Among these, my immediate next step would be to integrate age and contract data, as these directly inform actionable insights for player valuation and contract negotiations. You can make use of the leaderboard in it’s current state by manually accounting for a player’s ages. If the model is showing a strong distribution, say for Adam Vinitari, leadership would know not to offer a 5-year contract, recognizing potential future decline not fully captured by current performance metrics. This kind of player analysis would be improved by projecting their value into salary cap and making projections on what value they can bring, or incorporating collegiate priors for young players to get a better grasp of their range of outcomes.</p>
</section>
<section id="are-there-any-modelstechniquesareas-you-are-unfamiliar-with-that-might-improve-your-work-any-newforeign-methods-worth-researching" class="level2">
<h2 class="anchored" data-anchor-id="are-there-any-modelstechniquesareas-you-are-unfamiliar-with-that-might-improve-your-work-any-newforeign-methods-worth-researching">Are there any models/techniques/areas you are unfamiliar with that might improve your work? Any new/foreign methods worth researching?</h2>
<p>Gaussian processes are something I haven’t explored much outside of academics, but they would be worth looking into. The could provide uncertainty quantification and extrapolation for player ratings, particularly valuable when projecting performance into future seasons or estimating decline curves. With tracking-data, the recent movement with transformer architectures and deep-learning is making a lot of headway reducing the amount of feature engineering needed with the use of attention. I only recently learned of Bayesian Additive Regression Trees (BART), but with the popularity of gradient boosting methods in competitions like the Big Data Bowl and large scale prediction, I would be interested in looking into that for other prediction tasks. The main theme is that if it makes sense, I would continue looking for ways to apply Bayesian methods and improve ways we can look at decision making.</p>
</section>
<section id="closing-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="closing-thoughts">Closing Thoughts</h2>
<p>This was an incredibly fun take-home assessment. I appreciate upfront getting to do this, and being able to have something I can take away from this. I did all of this in bambi, because the API abstracted some of the components like predicting on new data. I included a standard PYMC implementation in the github repo as well: https://github.com/rplain1/just4kicks. And if the team is R/Stan, you might tell from my <code>ggplot</code> comment, but I enjoy that as well.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>